#include <cstdint>
#include <cstdlib>
#include <exception>
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <ostream>
#include <stdexcept>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <utility>
#include <vector>
#include <fstream>
#include <math.h>
#include "points.h"
#include "shader.h"
#include "point.h"
#include <chrono>
#include <random>
#include <unistd.h>  // for usleep

// TODO:
// - Create a functio nearest neighbour function to convert coords to grid position.

//to compile - g++ test.cpp glad.c -o test -lGL -lGLU -lglfw3 -lX11 -lXxf86vm -lXrandr -lpthread -lXi -ldl

#define ROW_SIZE 768
#define COLUMN_SIZE 1024
#define POINT_SIZE sizeof(point)
#define NEXT 1
#define PREVIOUS 0


/**
 * @brief Handler for keyboard/mouse inputs
 * 
 * @param window glfw window context
 */
void processInput(GLFWwindow *window, points* p)
{
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }

    if (glfwGetMouseButton(window,GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) 
    {
        double xpos, ypos;

        glfwGetCursorPos(window, &xpos, &ypos);

        int number_of_cells;

        std::cout << "Enter the number of cells \n" << std::endl;

        std::cin >> number_of_cells;

        p->generate_medical_cells((int) xpos, (int) ypos, number_of_cells); 
         
    }
}

/**
*   @brief Sets the size of the viewport, can also be used to scale w.r.t aspect ratio.
*
*/
void framebuffer_size_callback(GLFWwindow* window, int width, int height){
    
    // (left, bottom, left, top) size of the window
    glViewport(0, 0, width, height);
}

/**
* @brief Confirms whether or not window has initialised, if not throws an exception. 
*   
* @param window A pointer to the current window context
*/
void confirm_window_init(GLFWwindow* window)
{
    try
    {
        if(window == NULL)
        {
            throw std::runtime_error("Failed to intialize window.");
        }    
    }
    catch (const std::exception& e)
    {
        std::cout << e.what() << std::endl;
        glfwTerminate();
    }
}

/** 
*   @brief Check wether or not glad has intialised. Always do this after setting the current glfw window context. 
*/
void confirm_glad_has_loaded()
{
    try
    {
        if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress))
        {
            throw std::runtime_error("Failed to initializa GLAD");
        }    
    }
    catch (const std::exception& e)
    {
        std::cout << e.what() << std::endl;
    }
}

/**
*   @brief The following creates and intialises a shader program. 
*
*   @param argument1 Location of the vertex shader
*   @param argument2 Location of the fragment shader
*/
void initialise_shader_program(char* argument1, char* argument2)
{
    Shader s1(argument1,argument2);

    s1.use();
}

/**
* @brief Draws object
*
* @param object_buffer_id  The Buffer ID of the object data generated by OpenGL
*
*/
void draw_object(unsigned int object_buffer_id)
{
    glBindVertexArray(object_buffer_id);

    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    glBindVertexArray(0);
}

/**
 * @brief returns true or false randomly based on a bernoulli distribution
 * 
 * @return true 
 * @return false 
 */
bool randomTrueOrFalse() {
    static std::random_device rd;  

    static std::mt19937 gen(rd()); 

    static std::bernoulli_distribution dis(0.25); // Uniform distribution between 0 and 1

    return dis(gen); 
}

/**
 * @brief Assigns the coordinates and color of the point to be rendered.
 * 
 * @param grid The array of the point object. 
 * @param i index x
 * @param j index y
 * @param x_coord 
 * @param y_coord 
 */
void assign_coords_and_colors(point* &grid, int& i, int& j, float x_coord, float y_coord)
{   
    static int max_no_of_cancer_cells  = 196400;

    point* pixel = (grid + i*COLUMN_SIZE + j);

    pixel->x = x_coord;

    pixel->y = y_coord;

    if(randomTrueOrFalse() && max_no_of_cancer_cells > 0)
    {
        pixel->set_rgba(0.949f, 0.6f, 0.59f, 1.0f);

        pixel->type = 4;

        max_no_of_cancer_cells--;
    }
    else
    {   
        pixel->set_rgba(0.757f, 1.0f, 0.808f, 1.0f);

        pixel->type = 0;
    }
}

/**
 * @brief The following function intialises a blank grid by asigning a point a position on the screen. 
 * 
 * @param grid A 2D stl vector representing the 1024x768 grid of pixels
 */
void initialise_grid(point* grid)
{   
    int i = 0, j = 0;

    while(i < 768)
    {   
        float y_coord = i/768.0f*2.0f-1.0f;

        j = 0;

        while(j < 1024)
        {   
            float x_coord = j/1024.0f*2.0f-1.0f;

            assign_coords_and_colors(grid, i, j, x_coord, y_coord);

            j++;   
        }
        
        i++;
    }
}

void copy_grid(point* original_grid, point* copy_grid)
{
    int i = 0, j = 0;

    while(i < 768)
    {   
        float y_coord = i/768.0f*2.0f-1.0f;

        j = 0;

        while(j < 1024)
        {   
            float x_coord = j/1024.0f*2.0f-1.0f;

            *(copy_grid+i*COLUMN_SIZE+j) = *(original_grid+i*COLUMN_SIZE+j);

            j++;   
        }
        
        i++;
    }
}

int main(int argc, char *argv[])
{   
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1024, 768, "Cancer Cell Simulation",NULL,NULL);
    confirm_window_init(window);
    glfwMakeContextCurrent(window);
    confirm_glad_has_loaded();    
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

    point *point_grid;

    point_grid = new point[ROW_SIZE*COLUMN_SIZE*2+1];
    
    initialise_grid(point_grid);

    copy_grid(point_grid, (point_grid+ROW_SIZE*COLUMN_SIZE));

    int buffer_size =  ROW_SIZE*COLUMN_SIZE*POINT_SIZE*2;

    points p(&(point_grid)->x,buffer_size,sizeof(point)); 

    initialise_shader_program(argv[1], argv[2]);
    
    // --- Render Loop ---
    while(!glfwWindowShouldClose(window))
    {   
        auto start = std::chrono::high_resolution_clock::now();
        
        glClearColor(1.0f,1.0f,0.8f,1.0f);

        glClear(GL_COLOR_BUFFER_BIT);

        glDrawArrays(GL_POINTS, 0, COLUMN_SIZE*ROW_SIZE);

        // sleep(1);

        // if(p.current_buffer == PREVIOUS)
        // {
        //     p.switch_buffer(NEXT);
        // }
        // else
        // {
        //     p.switch_buffer(PREVIOUS);
        // }

        glfwPollEvents();
        
        p.generate_next_buffer();
        
        processInput(window, &p);

        glfwSwapBuffers(window);

        auto stop = std::chrono::high_resolution_clock::now();

        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);

        std::cout << "Time taken by loop: " << duration.count() << " milliseconds" << std::endl;

        std::cout << "fps: " << (float) 1000/duration.count() << std::endl;
    }

    glfwTerminate();

    return 0;
}   
